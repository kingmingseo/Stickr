# 검색 결과 중복 키 이슈 해결

> **트러블슈팅 문서**  
> 프로젝트: Stickr  
> 작성일: 20251031

<br/>

## 📋 목차
- [문제 정의](#-문제-정의)
- [발생 환경](#-발생-환경)
- [원인 분석](#-원인-분석)
- [해결 방법](#-해결-방법)
- [구현 상세](#-구현-상세)
- [결과 및 검증](#-결과-및-검증)
- [교훈 및 개선사항](#-교훈-및-개선사항)

<br/>

## 🔴 문제 정의

### 증상
검색 화면에서 무한 스크롤 사용 시 **FlatList에서 중복 키 경고**가 발생하고, **같은 스티커가 여러 번 표시**됨

### 에러 메시지

```
console.js:661 Encountered two children with the same key, 
`.$326d7445-631d-4a14-a7a3-0a5cb098b01e=28c19fafe-cf8d-4e7d-bb58-af11e1c6c6d6=25905f6b1-cde6-4aee-bd39-90c4884efd43`. 
Keys should be unique so that components maintain their identity across updates.
```

### 구체적인 문제 상황

1. **중복 데이터 표시**
   - 첫 페이지와 두 번째 페이지에 같은 스티커가 나타남
   - 사용자가 동일한 스티커를 여러 번 봄
   - FlatList 렌더링 성능 저하

2. **React 경고 발생**
   - `keyExtractor`에서 중복 키 감지
   - 개발 모드에서 빨간 경고 화면 표시

3. **특정 화면에만 발생**
   - **검색 화면**: 중복 발생 ❌
   - 홈 화면: 정상 작동 ✅
   - 즐겨찾기 화면: 정상 작동 ✅

<br/>

## 🌍 발생 환경

### 기술 스택
- **플랫폼**: React Native 0.81.4
- **데이터베이스**: Supabase (PostgreSQL)
- **주요 라이브러리**:
  - `@tanstack/react-query`: 데이터 패칭 및 캐싱
  - React Native `FlatList`: 목록 렌더링

### 데이터 구조
```typescript
interface Sticker {
  id: string;                    // UUID (고유 키)
  auto_increment_id: number;     // 자동 증가 ID
  like_count: number;            // 좋아요 수
  title: string;
  image_url: string;
  // ... 기타 필드
}
```

### 페이지네이션 방식
- **Cursor 기반**: `like_count|auto_increment_id` 형식
- **무한 스크롤**: React Query의 `useInfiniteQuery`
- **정렬**: `like_count DESC, auto_increment_id DESC`

<br/>

## 🔍 원인 분석

### 근본 원인: ORDER BY 누락

#### 문제 코드 (수정 전)

```typescript
// 문제가 있던 코드 (src/api/sticker.ts - searchStickers)
export const searchStickers = async ({ 
  searchText, 
  limit = 20, 
  cursor 
}: SearchStickersParams) => {
  let supabaseQuery = supabase
    .from('sticker')
    .select('*, user_favorites(user_id)')
    .or(orFilter)
    .limit(limit);
    // ORDER BY가 없음

  if (cursor) {
    supabaseQuery = supabaseQuery.or(
      `like_count.lt.${likeCursor},and(like_count.eq.${likeCursor},auto_increment_id.lt.${idCursor})`
    );
  }

  const { data, error } = await supabaseQuery;
  // ...
};
```

### 왜 중복이 발생했는가?

#### 1. PostgreSQL의 정렬 없는 쿼리

**정렬이 없으면** 데이터베이스는 **임의의 순서**로 결과를 반환합니다.

```sql
-- 정렬 없음
SELECT * FROM sticker WHERE ... LIMIT 20;
-- 결과: [ID:50, ID:35, ID:80, ID:42, ...] (무작위 순서)
```

이 순서는:
- 예측 불가능
- 실행마다 달라질 수 있음
- 내부 저장 순서에 의존

#### 2. Cursor 페이지네이션이 깨짐

``` 
[예시 페이지 1 요청]
쿼리: WHERE 검색조건 LIMIT 20
결과: [ID:50, ID:35, ID:80, ID:42, ...]
      like_count: [15,  12,  10,  10, ...]
마지막 항목: like_count=10, id=42
→ nextCursor = "10|42"

[예시 페이지 2 요청] (cursor="10|42")
쿼리: WHERE 검색조건 
      AND (like_count < 10 OR (like_count = 10 AND id < 42))
      LIMIT 20
결과: [ID:35, ID:25, ID:50, ...]
      ↑ ID:35와 ID:50은 이미 페이지 1에 있었음!
```

**문제**:
- Cursor 조건은 `like_count < 10 OR ...`
- 하지만 정렬이 없어서 `like_count=12`인 ID:35가 페이지 2에 다시 나타남
- 페이지 1에서 무작위 순서로 나왔던 데이터가 페이지 2에 다시 등장

#### 3. flatMap으로 합칠 때 중복 발생

```typescript
// React Query의 useInfiniteQuery
const stickers = data.pages.flatMap(page => page.data);
// [ID:50, ID:35, ..., ID:35, ID:50, ...]
// 중복 발생
```

FlatList의 `keyExtractor`:
```typescript
<FlatList
  data={stickers}
  keyExtractor={item => item.id} // ID:35가 2번 나타남, 중복 키 경고
/>
```

<br/>

## ✅ 해결 방법

### 핵심 해결책: ORDER BY 추가

```typescript
// 수정된 코드
let supabaseQuery = supabase
  .from('sticker')
  .select('*, user_favorites(user_id)')
  .or(orFilter)
  .order('like_count', { ascending: false })        // 좋아요 수 내림차순
  .order('auto_increment_id', { ascending: false }) // 동일 좋아요 시 최신 우선
  .limit(limit);

if (cursor) {
  const [likeStr, idStr] = cursor.split('|');
  const likeCursor = parseInt(likeStr);
  const idCursor = parseInt(idStr);
  
  supabaseQuery = supabaseQuery.or(
    `like_count.lt.${likeCursor},and(like_count.eq.${likeCursor},auto_increment_id.lt.${idCursor})`
  );
}
```

### 왜 이제 작동하는가?

1. **일관된 순서 보장**
   - 항상 `like_count DESC, auto_increment_id DESC` 순서로 반환
   - 실행마다 동일한 결과 보장

2. **Cursor 조건과 일치**
   - Cursor는 `like_count < X OR (like_count = X AND id < Y)`
   - 정렬 순서와 정확히 일치

3. **페이지 경계 명확**
   - 각 페이지의 마지막 항목이 명확한 기준점
   - 다음 페이지는 정확히 그 다음부터 시작

<br/>

## 🛠 구현 상세

### 1. 수정된 API 함수

#### 파일: `src/api/sticker.ts`

```typescript
export const searchStickers = async ({
  searchText,
  limit = 20,
  cursor,
  userId,
}: SearchStickersParams): Promise<StickersResponse> => {
  // 검색 조건 생성
  const orFilter = `title.ilike.%${searchText}%,tags.cs.{${searchText}}`;

  // 기본 쿼리 (ORDER BY 포함!)
  let supabaseQuery = supabase
    .from('sticker')
    .select('*, user_favorites(user_id)')
    .or(orFilter)
    .order('like_count', { ascending: false })
    .order('auto_increment_id', { ascending: false });

  // Cursor 페이지네이션
  if (cursor) {
    const [likeStr, idStr] = cursor.split('|');
    const likeCursor = parseInt(likeStr, 10);
    const idCursor = parseInt(idStr, 10);

    // like_count < X OR (like_count = X AND auto_increment_id < Y)
    supabaseQuery = supabaseQuery.or(
      `like_count.lt.${likeCursor},and(like_count.eq.${likeCursor},auto_increment_id.lt.${idCursor})`
    );
  }

  // limit은 마지막에!
  supabaseQuery = supabaseQuery.limit(limit);

  const { data, error } = await supabaseQuery;

  if (error) {
    throw new Error(`검색 실패: ${error.message}`);
  }

  // 스티커 데이터 매핑
  const stickers: Sticker[] = (data || []).map(item => ({
    ...item,
    isFavorite: userId
      ? item.user_favorites?.some((fav: any) => fav.user_id === userId)
      : false,
  }));

  // 다음 커서 생성
  let nextCursor: string | null = null;
  if (stickers.length === limit) {
    const lastSticker = stickers[stickers.length - 1];
    nextCursor = `${lastSticker.like_count}|${lastSticker.auto_increment_id}`;
  }

  return { data: stickers, nextCursor };
};
```

### 2. Supabase 쿼리 체이닝 순서

**올바른 순서** (중요!):
```typescript
supabase
  .from('table')
  .select('*')           // 1. 필드 선택
  .or(검색조건)           // 2. WHERE 조건
  .order('field1')       // 3. 정렬 (필수!)
  .order('field2')       // 4. 보조 정렬
  .or(cursor조건)         // 5. 페이지네이션 조건
  .limit(N)              // 6. 개수 제한
```

### 3. React Query 훅

#### 파일: `src/hooks/query/useSearchStickers.ts`

```typescript
export const useSearchStickers = (searchText: string) => {
  const { userId } = useAuth();

  return useInfiniteQuery({
    queryKey: ['searchStickers', searchText, userId],
    queryFn: ({ pageParam }) =>
      searchStickers({
        searchText,
        cursor: pageParam,
        userId,
      }),
    initialPageParam: undefined,
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    enabled: searchText.length > 0,
    staleTime: 1000 * 60 * 5,  // 5분
    gcTime: 1000 * 60 * 10,    // 10분
  });
};
```

### 4. 화면에서 사용

#### 파일: `src/screens/search/SearchScreen.tsx`

```tsx
const SearchScreen = () => {
  const [activeQuery, setActiveQuery] = useState('');
  
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useSearchStickers(activeQuery);

  // 모든 페이지의 데이터를 평탄화
  const stickers = data?.pages.flatMap(page => page.data) ?? [];

  return (
    <FlatList
      data={stickers}
      keyExtractor={(item, index) => `${item.id}-${index}`} // 인덱스 추가로 완전 고유 보장
      renderItem={({ item }) => <StickerCard sticker={item} />}
      onEndReached={() => {
        if (hasNextPage && !isFetchingNextPage) {
          fetchNextPage();
        }
      }}
    />
  );
};
```

### 5. 디버깅 로그 추가

```typescript
// 개발 모드에서 중복 확인
if (__DEV__) {
  const ids = stickers.map(s => s.id);
  const uniqueIds = new Set(ids);
  
  if (ids.length !== uniqueIds.size) {
    console.warn('⚠️ 중복 ID 발견!', {
      total: ids.length,
      unique: uniqueIds.size,
      duplicates: ids.filter((id, index) => ids.indexOf(id) !== index),
    });
  } else {
    console.log('✅ 중복 없음', {
      total: ids.length,
    });
  }
}
```

<br/>

## 📊 결과 및 검증

### 테스트 시나리오

#### 시나리오 1: 일반 검색

```
1. "고양이" 검색
2. 첫 페이지 로드 (20개 스티커)
3. 스크롤하여 두 번째 페이지 로드
4. 결과: 중복 없음

디버그 로그:
중복 없음 { total: 40 }
```

#### 시나리오 2: 동일 like_count 케이스

```
데이터:
- ID:50, like_count:10, auto_increment_id:50
- ID:49, like_count:10, auto_increment_id:49
- ID:48, like_count:10, auto_increment_id:48

첫 페이지: [50, 49, 48, ...]
두 번째 페이지: [47, 46, ...]
결과: 중복 없음
```

#### 시나리오 3: 빠른 연속 스크롤

```
1. "스티커" 검색
2. 빠르게 스크롤하여 5페이지까지 로드
3. 결과: 중복 없음

디버그 로그:
중복 없음 { total: 100 }
```

### 비교: 다른 화면들

#### 홈 화면 (`getRecentStickers`)
```typescript
// ORDER BY 있음 (처음부터)
.order('auto_increment_id', { ascending: false })
```
문제 없었음

#### 즐겨찾기 화면 (`getMyFavorites`)
```typescript
// ORDER BY 있음 (처음부터)
.order('created_at', { ascending: false })
.order('sticker_id', { ascending: false })
```
문제 없었음

#### 검색 화면 (`searchStickers`)
```typescript
// ORDER BY 없음 (수정 전)
```
문제 발생!

**결론**: 검색 API에만 ORDER BY가 누락되어 있었음

<br/>

## 🎓 교훈 및 개선사항

### 핵심 교훈

1. **Cursor 페이지네이션의 기본 원칙**
   ```
   페이지네이션 = 정렬 + 제한 + Cursor
   정렬이 없으면 Cursor가 무의미함
   ```

2. **PostgreSQL의 특성**
   - ORDER BY 없이 쿼리하면 순서가 예측 불가능
   - 내부 저장 순서는 변경될 수 있음
   - 항상 명시적으로 정렬해야 함

3. **일관성의 중요성**
   - 다른 API들은 정렬이 있었음
   - 검색 API만 예외적으로 누락
   - 코드 템플릿이나 체크리스트가 필요

4. **디버깅 로그의 가치**
   - 중복 확인 로그가 문제 파악에 결정적 도움
   - 개발 모드에서 자동으로 검증하는 것이 중요




### 관련 문서

- [Supabase Pagination](https://supabase.com/docs/guides/api/pagination)
- [PostgreSQL ORDER BY](https://www.postgresql.org/docs/current/queries-order.html)
- [React Query Infinite Queries](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)

<br/>

---

<div align="center">

**✅ 해결 완료**  
검색 시 중복 키 에러 및 중복 데이터 표시 완전 해결

**해결 일시**: 2024.10.17  
**최종 수정**: `src/api/sticker.ts` - `searchStickers()` 함수

</div>
